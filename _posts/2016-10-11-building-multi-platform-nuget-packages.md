---
layout: post
title: "Building multi-platform NuGet packages"
date: 2016-10-11
categories: dotnet core standard framework nuget
featured_image: /images/cover.jpg
tags:
- draft
---
**.NET Core** was released several months ago now and as such people are itching to experiment with porting their code to this new framework. This may prove to be in vain owing to the lack of **NuGet** packages that are compatible with **.NET Core**, or rather the **.NET Standard**. This problem is not just limited to 3<sup>rd</sup> party public packages, but also many private packages created in IT departments; the inspiration for this post.

**CAVEAT**: This post demonstrates creating a brand new package to limit the amount of noise generated by compatibility issues. As such, given the change to the project structures with vNext, I would recommend porting projects bit by bit into this new world. **Octopus Deploy** have created the very useful [I Can Has .NET Core](https://icanhasdot.net/){:target="_blank"} to analyse existing projects for compatibility with the .NET Standard, depending on your needs this can prevent a chunk of wasted effort. Another tool is [Reverse Package Search](https://packagesearch.azurewebsites.net/){:target="_blank"} which allows you to identify packages given type names.

### Prerequisites
You will need **Visual Studio 2015** and **.NET Core** as described on the [.NET Core](https://www.microsoft.com/net/core#windows){:target="_blank"} site. It is possible to achieve all this using the **.NET Core CLI** and **Visual Studio Code**, but I find the combination of **Visual Studio 2015** and **Resharper** very compelling still. Don't worry if you don't use **Resharper**, it won't prevent you from completing the task.

### Creating the solution
Open **Visual Studio** and create a **New Project** using the **Class Library (.NET Core)** template. Personally, I like to have the projects in the `src` folder, this involves some fiddling but results in a cleaner folder structure for larger solutions.

<div class="figcaption">c:\blog\my-nuget-package\</div>
{% highlight tree %}
 ├─MyNuGetPackage.sln
 └─src
    └─MyNuGetPackage
       ├─MyNuGetPackage.xproj
       ├─Utils.cs
       ├─project.json
       ├─project.lock.json
       └─Properties
          └─AssemblyInfo.cs
{% endhighlight %}

By default your `project.json` will contain just a single framework, the **.NET Standard Library 1.6**. I'm not aware of the need for the `imports` tag, so it will be removed it later.

<div class="figcaption">src\MyNuGetPackage\project.json</div>
{% highlight json %}
{
   "version": "1.0.0-*",
   "dependencies": {
      "NETStandard.Library": "1.6.0"
   },
   "frameworks": {
      "netstandard1.6": {
         "imports": "dnxcore50"
      }
   }
}
{% endhighlight %}

In order to add additional frameworks to your **NuGet** package, simply add the respective tags to the `frameworks` tag. In the example, we are adding the **.NET Framework 4.5.1**. Notice that the `framework` tag also supports the `dependencies` tag for specifying **NuGet** packages per framework as opposed to every framework.

<div class="figcaption">src\MyNuGetPackage\project.json</div>
{% highlight json %}
{
   "version": "1.0.0-*",
   "frameworks": {
      "netstandard1.6": {
         "dependencies": {
            "Microsoft.AspNetCore.Http.Abstractions": "1.0.0"
         }
      },
      "net451": {
         "dependencies": {
            "Microsoft.Owin": "3.0.1"
         }
      }
   }
}
{% endhighlight %}

By convention, each framework that you add to the `project.json` file will cause a symbol will be defined to allow conditional compilation. In our example the `netstandard1.6` defines `NETSTANDARD1_6` and similarly `net451` defines `NET451`. This will be invaluable as your use-cases become more complex.

<div class="figcaption">src\MyNuGetPackage\Utils.cs</div>
{% highlight csharp %}
namespace MyNuGetPackage
{
   using System;
   using System.Threading.Tasks;
#if NET451
   using Microsoft.Owin;
#elif NETSTANDARD1_6
   using Microsoft.AspNetCore.Http;
#endif

   public class Utils
   {
      public string GetFramework()
      {
         throw new NotImplementedException();
      }

#if NET451
      public Task NotFoundHandlerAsync(IOwinContext context)
#elif NETSTANDARD1_6
      public Task NotFoundHandlerAsync(HttpContext context)
#endif
      {
         throw new NotImplementedException();
      }
   }
}
{% endhighlight %}

### Adding some tests
We want to drive out the behaviour using tests and also protect against regression defects, so we need to introduce a testing framework into our solution. Along with **Microsoft**, I had previously moved towards **xUnit** as my testing framework of choice, however I found it easier to test multiple targets using **NUnit** which has recently gained **.NET Core** support.

Create another **New Project** using the **Class Library (.NET Core)** template. You will need to change the `project.json` file manually as before. [This post](http://www.alteridem.net/2016/06/18/nunit-3-testing-net-core-rc2/){:target="_blank"} from Rob Prouse runs through this step in more detail.

<div class="figcaption">src\MyNuGetPackage.Tests\project.json</div>
{% highlight json %}
{
   "version": "1.0.0-*",
   "testRunner": "nunit",
   "dependencies": {
      "NUnit": "3.5.0",
      "Shouldly": "2.8.2",
      "dotnet-test-nunit": "3.4.0-beta-2",
      "MyNuGetPackage": {
         "target": "project"
      }
   },
   "frameworks": {
      "netcoreapp1.0": {
         "imports": "portable-net45+win8",
         "dependencies": {
            "Microsoft.NETCore.App": {
               "version": "1.0.1",
               "type": "platform"
            }
         }
      },
      "net451": { }
   }
}
{% endhighlight %}

Create a test in the new test project.

<div class="figcaption">src\MyNuGetPackage.Tests\simple_scenario.cs</div>
{% highlight csharp %}
namespace MyNuGetPackage.Tests
{
   using MyNuGetPackage;
   using NUnit.Framework;
   using Shouldly;

   public class simple_scenario
   {
      [Test]
      public void return_framework()
      {
         var testSubject = new Utils();
         var result = testSubject.GetFramework();

#if NET451
         result.ShouldBe("net451");
#elif NETCOREAPP1_0
         result.ShouldBe("netstandard1.6");
#endif
      }
   }
}

{% endhighlight %}

Running `dotnet test` on the command line from the `src\MyNuGetPackage.Tests` folder will execute the test in both frameworks. However, we haven't implemented the function yet, so both tests will fail until we implement the `GetFramework` function.

<div class="figcaption">src\MyNuGetPackage\Utils.cs (GetFramework)</div>
{% highlight csharp %}
      public string GetFramework()
      {
#if NET451
         return "net451";
#elif NETSTANDARD1_6
         return "netstandard1.6";
#endif
      }
{% endhighlight %}

### Building locally
I've recently been introduced to the **Powershell** based build automation tool **psake**. It offers a good balance of declarative and iterative styles and integrates easily with **AppVeyor**, perfect for the next post in this series.

It is possible to bootstrap **psake** to avoid adding the scripts to your repository, but the two scripts required are pretty small, so for now just download `psake.psd1` and `psake.psm1` from [https://github.com/psake/psake](https://github.com/psake/psake){:target="_blank"} and store them in the `build` folder.

You will also need the **psake** build script `build.ps1` and a batch file `_build.bat` to invoke it.

<div class="figcaption">build\build.ps1</div>
{% highlight powershell %}
properties {
   $BasePath = Resolve-Path ..
   $SrcPath = "$BasePath\src"
   $ArtifactsPath = "$BasePath\artifacts"
   $ProjectJsonPath = "$SrcPath\Burble\project.json"
   $TestProjectJsonPath = "$SrcPath\Banshee.Tests\project.json"
   $Configuration = if ($Configuration) {$Configuration} else { "Debug" }
}

task default -depends Clean, Build, Test, Package

task Clean {
   if (Test-Path -path $ArtifactsPath)
   {
      Remove-Item -path $ArtifactsPath -Recurse -Force
   }

   New-Item -Path $ArtifactsPath -ItemType Directory
}

task Build {
   exec { dotnet restore $ProjectJsonPath }
   exec { dotnet build $ProjectJsonPath -c $Configuration --no-incremental }
}

task Test -depends Build {
   exec { dotnet restore $TestProjectJsonPath }
   exec { dotnet test $TestProjectJsonPath -c $Configuration }
}

task Package -depends Build {
   exec { dotnet pack $ProjectJsonPath -c $Configuration -o $ArtifactsPath }
}
{% endhighlight %}

<div class="figcaption">_build.bat</div>
{% highlight batch %}
@echo off
powershell "Import-Module .\build\psake.psm1; Invoke-Psake .\build\build.ps1; exit $LASTEXITCODE;"
{% endhighlight %}

Running the `_build.bat` batch file will build, test and package our project using the **.NET Core CLI** into a **NuGet** package. The `package` step of the build will create the package file `MyNuGetPackage.1.0.0.nupkg` in the `artifacts` folder and since a **NuGet** package is just a `.zip` file, renaming it as such allows you to examine the contents.

<div class="figcaption">artifacts\MyNuGetPackage.1.0.0.nupkg.zip</div>
{% highlight tree %}
 ├─MyNuGetPackage.nuspec
 ├─[Content_Types].xml
 ├─lib
 │  ├─net451
 │  │  └─MyNuGetPackage.dll
 │  │
 │  └─netstandard1.6
 │     └─MyNuGetPackage.dll
 └─_rels
    └─.rels
{% endhighlight %}

### Summary
We have created a **NuGet** package that can be consumed by multiple platforms, albeit a little contrived, but it can be extended for real world packages. In the next post in the series, we will create a continuous delivery pipeline in **AppVeyor** that will publish the package at [www.nuget.org](https://www.nuget.org/){:target="_blank"}.